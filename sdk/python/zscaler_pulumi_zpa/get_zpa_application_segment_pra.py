# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs
from ._inputs import *

__all__ = [
    'GetZPAApplicationSegmentPRAResult',
    'AwaitableGetZPAApplicationSegmentPRAResult',
    'get_zpa_application_segment_pra',
    'get_zpa_application_segment_pra_output',
]

@pulumi.output_type
class GetZPAApplicationSegmentPRAResult:
    """
    A collection of values returned by getZPAApplicationSegmentPRA.
    """
    def __init__(__self__, bypass_type=None, config_space=None, description=None, domain_names=None, double_encrypt=None, enabled=None, health_check_type=None, health_reporting=None, id=None, ip_anchored=None, is_cname_enabled=None, name=None, passive_health_enabled=None, segment_group_id=None, segment_group_name=None, server_groups=None, sra_apps=None, tcp_port_ranges=None, udp_port_ranges=None):
        if bypass_type and not isinstance(bypass_type, str):
            raise TypeError("Expected argument 'bypass_type' to be a str")
        pulumi.set(__self__, "bypass_type", bypass_type)
        if config_space and not isinstance(config_space, str):
            raise TypeError("Expected argument 'config_space' to be a str")
        pulumi.set(__self__, "config_space", config_space)
        if description and not isinstance(description, str):
            raise TypeError("Expected argument 'description' to be a str")
        pulumi.set(__self__, "description", description)
        if domain_names and not isinstance(domain_names, list):
            raise TypeError("Expected argument 'domain_names' to be a list")
        pulumi.set(__self__, "domain_names", domain_names)
        if double_encrypt and not isinstance(double_encrypt, bool):
            raise TypeError("Expected argument 'double_encrypt' to be a bool")
        pulumi.set(__self__, "double_encrypt", double_encrypt)
        if enabled and not isinstance(enabled, bool):
            raise TypeError("Expected argument 'enabled' to be a bool")
        pulumi.set(__self__, "enabled", enabled)
        if health_check_type and not isinstance(health_check_type, str):
            raise TypeError("Expected argument 'health_check_type' to be a str")
        pulumi.set(__self__, "health_check_type", health_check_type)
        if health_reporting and not isinstance(health_reporting, str):
            raise TypeError("Expected argument 'health_reporting' to be a str")
        pulumi.set(__self__, "health_reporting", health_reporting)
        if id and not isinstance(id, str):
            raise TypeError("Expected argument 'id' to be a str")
        pulumi.set(__self__, "id", id)
        if ip_anchored and not isinstance(ip_anchored, bool):
            raise TypeError("Expected argument 'ip_anchored' to be a bool")
        pulumi.set(__self__, "ip_anchored", ip_anchored)
        if is_cname_enabled and not isinstance(is_cname_enabled, bool):
            raise TypeError("Expected argument 'is_cname_enabled' to be a bool")
        pulumi.set(__self__, "is_cname_enabled", is_cname_enabled)
        if name and not isinstance(name, str):
            raise TypeError("Expected argument 'name' to be a str")
        pulumi.set(__self__, "name", name)
        if passive_health_enabled and not isinstance(passive_health_enabled, bool):
            raise TypeError("Expected argument 'passive_health_enabled' to be a bool")
        pulumi.set(__self__, "passive_health_enabled", passive_health_enabled)
        if segment_group_id and not isinstance(segment_group_id, str):
            raise TypeError("Expected argument 'segment_group_id' to be a str")
        pulumi.set(__self__, "segment_group_id", segment_group_id)
        if segment_group_name and not isinstance(segment_group_name, str):
            raise TypeError("Expected argument 'segment_group_name' to be a str")
        pulumi.set(__self__, "segment_group_name", segment_group_name)
        if server_groups and not isinstance(server_groups, list):
            raise TypeError("Expected argument 'server_groups' to be a list")
        pulumi.set(__self__, "server_groups", server_groups)
        if sra_apps and not isinstance(sra_apps, list):
            raise TypeError("Expected argument 'sra_apps' to be a list")
        pulumi.set(__self__, "sra_apps", sra_apps)
        if tcp_port_ranges and not isinstance(tcp_port_ranges, list):
            raise TypeError("Expected argument 'tcp_port_ranges' to be a list")
        pulumi.set(__self__, "tcp_port_ranges", tcp_port_ranges)
        if udp_port_ranges and not isinstance(udp_port_ranges, list):
            raise TypeError("Expected argument 'udp_port_ranges' to be a list")
        pulumi.set(__self__, "udp_port_ranges", udp_port_ranges)

    @property
    @pulumi.getter(name="bypassType")
    def bypass_type(self) -> str:
        """
        (string) Indicates whether users can bypass ZPA to access applications.
        """
        return pulumi.get(self, "bypass_type")

    @property
    @pulumi.getter(name="configSpace")
    def config_space(self) -> str:
        """
        (string)
        """
        return pulumi.get(self, "config_space")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        (string) Description of the application.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="domainNames")
    def domain_names(self) -> Sequence[str]:
        """
        (string) List of domains and IPs.
        """
        return pulumi.get(self, "domain_names")

    @property
    @pulumi.getter(name="doubleEncrypt")
    def double_encrypt(self) -> bool:
        """
        (bool) Whether Double Encryption is enabled or disabled for the app.
        """
        return pulumi.get(self, "double_encrypt")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        (bool) Whether this application is enabled or not
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="healthCheckType")
    def health_check_type(self) -> str:
        """
        (string)
        """
        return pulumi.get(self, "health_check_type")

    @property
    @pulumi.getter(name="healthReporting")
    def health_reporting(self) -> str:
        """
        (string) Whether health reporting for the app is Continuous or On Access. Supported values: NONE, ON_ACCESS, CONTINUOUS.
        """
        return pulumi.get(self, "health_reporting")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ipAnchored")
    def ip_anchored(self) -> bool:
        """
        (bool)
        """
        return pulumi.get(self, "ip_anchored")

    @property
    @pulumi.getter(name="isCnameEnabled")
    def is_cname_enabled(self) -> bool:
        """
        (bool) Indicates if the Zscaler Client Connector (formerly Zscaler App or Z App) receives CNAME DNS records from the connectors.
        """
        return pulumi.get(self, "is_cname_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="passiveHealthEnabled")
    def passive_health_enabled(self) -> bool:
        """
        (bool)
        """
        return pulumi.get(self, "passive_health_enabled")

    @property
    @pulumi.getter(name="segmentGroupId")
    def segment_group_id(self) -> str:
        """
        (String) Segment Group IDs
        """
        return pulumi.get(self, "segment_group_id")

    @property
    @pulumi.getter(name="segmentGroupName")
    def segment_group_name(self) -> str:
        return pulumi.get(self, "segment_group_name")

    @property
    @pulumi.getter(name="serverGroups")
    def server_groups(self) -> Sequence['outputs.GetZPAApplicationSegmentPRAServerGroupResult']:
        """
        (string) List of Server Group IDs
        * `id:` - (string) List of Server Group IDs
        """
        return pulumi.get(self, "server_groups")

    @property
    @pulumi.getter(name="sraApps")
    def sra_apps(self) -> Sequence['outputs.GetZPAApplicationSegmentPRASraAppResult']:
        """
        (string) TCP port ranges used to access the app.
        * `app_id:` - (string)
        * `name:` - (string) Name of the Privileged Remote Access
        * `description:` - (string) Description of the Privileged Remote Access
        * `domain:` - (string) Domain name of the Privileged Remote Access
        """
        return pulumi.get(self, "sra_apps")

    @property
    @pulumi.getter(name="tcpPortRanges")
    def tcp_port_ranges(self) -> Sequence[str]:
        """
        (string) TCP port ranges used to access the app.
        """
        return pulumi.get(self, "tcp_port_ranges")

    @property
    @pulumi.getter(name="udpPortRanges")
    def udp_port_ranges(self) -> Sequence[str]:
        """
        (string) UDP port ranges used to access the app.
        """
        return pulumi.get(self, "udp_port_ranges")


class AwaitableGetZPAApplicationSegmentPRAResult(GetZPAApplicationSegmentPRAResult):
    # pylint: disable=using-constant-test
    def __await__(self):
        if False:
            yield self
        return GetZPAApplicationSegmentPRAResult(
            bypass_type=self.bypass_type,
            config_space=self.config_space,
            description=self.description,
            domain_names=self.domain_names,
            double_encrypt=self.double_encrypt,
            enabled=self.enabled,
            health_check_type=self.health_check_type,
            health_reporting=self.health_reporting,
            id=self.id,
            ip_anchored=self.ip_anchored,
            is_cname_enabled=self.is_cname_enabled,
            name=self.name,
            passive_health_enabled=self.passive_health_enabled,
            segment_group_id=self.segment_group_id,
            segment_group_name=self.segment_group_name,
            server_groups=self.server_groups,
            sra_apps=self.sra_apps,
            tcp_port_ranges=self.tcp_port_ranges,
            udp_port_ranges=self.udp_port_ranges)


def get_zpa_application_segment_pra(id: Optional[str] = None,
                                    name: Optional[str] = None,
                                    tcp_port_ranges: Optional[Sequence[pulumi.InputType['GetZPAApplicationSegmentPRATcpPortRangeArgs']]] = None,
                                    udp_port_ranges: Optional[Sequence[pulumi.InputType['GetZPAApplicationSegmentPRAUdpPortRangeArgs']]] = None,
                                    opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetZPAApplicationSegmentPRAResult:
    """
    Use the **zpa_application_segment_pra** data source to get information about an application segment for Privileged Remote Access in the Zscaler Private Access cloud. This resource can then be referenced in an access policy rule, access policy timeout rule, access policy client forwarding rule and inspection policy. This resource supports Privileged Remote Access for both `RDP` and `SSH`.

    ## Example Usage

    ```python
    import pulumi
    import pulumi_zpa as zpa

    this = zpa.get_zpa_application_segment_pra(name="PRA_Example")
    ```

    ```python
    import pulumi
    import pulumi_zpa as zpa

    this = zpa.get_zpa_application_segment_pra(id="123456789")
    ```


    :param str name: The name of the PRA Application Segment to be exported.
    :param Sequence[pulumi.InputType['GetZPAApplicationSegmentPRATcpPortRangeArgs']] tcp_port_ranges: (string) TCP port ranges used to access the app.
           * `from:`
           * `to:`
    :param Sequence[pulumi.InputType['GetZPAApplicationSegmentPRAUdpPortRangeArgs']] udp_port_ranges: (string) UDP port ranges used to access the app.
           * `from:`
           * `to:`
    """
    __args__ = dict()
    __args__['id'] = id
    __args__['name'] = name
    __args__['tcpPortRanges'] = tcp_port_ranges
    __args__['udpPortRanges'] = udp_port_ranges
    opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke('zpa:index/getZPAApplicationSegmentPRA:getZPAApplicationSegmentPRA', __args__, opts=opts, typ=GetZPAApplicationSegmentPRAResult).value

    return AwaitableGetZPAApplicationSegmentPRAResult(
        bypass_type=__ret__.bypass_type,
        config_space=__ret__.config_space,
        description=__ret__.description,
        domain_names=__ret__.domain_names,
        double_encrypt=__ret__.double_encrypt,
        enabled=__ret__.enabled,
        health_check_type=__ret__.health_check_type,
        health_reporting=__ret__.health_reporting,
        id=__ret__.id,
        ip_anchored=__ret__.ip_anchored,
        is_cname_enabled=__ret__.is_cname_enabled,
        name=__ret__.name,
        passive_health_enabled=__ret__.passive_health_enabled,
        segment_group_id=__ret__.segment_group_id,
        segment_group_name=__ret__.segment_group_name,
        server_groups=__ret__.server_groups,
        sra_apps=__ret__.sra_apps,
        tcp_port_ranges=__ret__.tcp_port_ranges,
        udp_port_ranges=__ret__.udp_port_ranges)


@_utilities.lift_output_func(get_zpa_application_segment_pra)
def get_zpa_application_segment_pra_output(id: Optional[pulumi.Input[Optional[str]]] = None,
                                           name: Optional[pulumi.Input[Optional[str]]] = None,
                                           tcp_port_ranges: Optional[pulumi.Input[Optional[Sequence[pulumi.InputType['GetZPAApplicationSegmentPRATcpPortRangeArgs']]]]] = None,
                                           udp_port_ranges: Optional[pulumi.Input[Optional[Sequence[pulumi.InputType['GetZPAApplicationSegmentPRAUdpPortRangeArgs']]]]] = None,
                                           opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetZPAApplicationSegmentPRAResult]:
    """
    Use the **zpa_application_segment_pra** data source to get information about an application segment for Privileged Remote Access in the Zscaler Private Access cloud. This resource can then be referenced in an access policy rule, access policy timeout rule, access policy client forwarding rule and inspection policy. This resource supports Privileged Remote Access for both `RDP` and `SSH`.

    ## Example Usage

    ```python
    import pulumi
    import pulumi_zpa as zpa

    this = zpa.get_zpa_application_segment_pra(name="PRA_Example")
    ```

    ```python
    import pulumi
    import pulumi_zpa as zpa

    this = zpa.get_zpa_application_segment_pra(id="123456789")
    ```


    :param str name: The name of the PRA Application Segment to be exported.
    :param Sequence[pulumi.InputType['GetZPAApplicationSegmentPRATcpPortRangeArgs']] tcp_port_ranges: (string) TCP port ranges used to access the app.
           * `from:`
           * `to:`
    :param Sequence[pulumi.InputType['GetZPAApplicationSegmentPRAUdpPortRangeArgs']] udp_port_ranges: (string) UDP port ranges used to access the app.
           * `from:`
           * `to:`
    """
    ...
