// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package zpa

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type ZPABrowserAccess struct {
	pulumi.CustomResourceState

	// Indicates whether users can bypass ZPA to access applications. Default: NEVER. Supported values: ALWAYS, NEVER, ON_NET.
	// The value NEVER indicates the use of the client forwarding policy.
	BypassType     pulumi.StringPtrOutput                   `pulumi:"bypassType"`
	ClientlessApps ZPABrowserAccessClientlessAppArrayOutput `pulumi:"clientlessApps"`
	ConfigSpace    pulumi.StringPtrOutput                   `pulumi:"configSpace"`
	// Description of the application.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// List of domains and IPs.
	DomainNames pulumi.StringArrayOutput `pulumi:"domainNames"`
	// Whether Double Encryption is enabled or disabled for the app.
	DoubleEncrypt   pulumi.BoolPtrOutput `pulumi:"doubleEncrypt"`
	Enabled         pulumi.BoolOutput    `pulumi:"enabled"`
	HealthCheckType pulumi.StringOutput  `pulumi:"healthCheckType"`
	// Whether health reporting for the app is Continuous or On Access. Supported values: NONE, ON_ACCESS, CONTINUOUS.
	HealthReporting pulumi.StringOutput    `pulumi:"healthReporting"`
	IcmpAccessType  pulumi.StringPtrOutput `pulumi:"icmpAccessType"`
	IpAnchored      pulumi.BoolPtrOutput   `pulumi:"ipAnchored"`
	// Indicates if the Zscaler Client Connector (formerly Zscaler App or Z App) receives CNAME DNS records from the
	// connectors.
	IsCnameEnabled pulumi.BoolPtrOutput `pulumi:"isCnameEnabled"`
	// Name of the application.
	Name                 pulumi.StringOutput `pulumi:"name"`
	PassiveHealthEnabled pulumi.BoolOutput   `pulumi:"passiveHealthEnabled"`
	SegmentGroupId       pulumi.StringOutput `pulumi:"segmentGroupId"`
	SegmentGroupName     pulumi.StringOutput `pulumi:"segmentGroupName"`
	// List of the server group IDs.
	ServerGroups ZPABrowserAccessServerGroupArrayOutput `pulumi:"serverGroups"`
	// TCP port ranges used to access the app.
	TcpPortRanges pulumi.StringArrayOutput `pulumi:"tcpPortRanges"`
	// UDP port ranges used to access the app.
	UdpPortRanges pulumi.StringArrayOutput `pulumi:"udpPortRanges"`
}

// NewZPABrowserAccess registers a new resource with the given unique name, arguments, and options.
func NewZPABrowserAccess(ctx *pulumi.Context,
	name string, args *ZPABrowserAccessArgs, opts ...pulumi.ResourceOption) (*ZPABrowserAccess, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ClientlessApps == nil {
		return nil, errors.New("invalid value for required argument 'ClientlessApps'")
	}
	if args.DomainNames == nil {
		return nil, errors.New("invalid value for required argument 'DomainNames'")
	}
	if args.SegmentGroupId == nil {
		return nil, errors.New("invalid value for required argument 'SegmentGroupId'")
	}
	if args.ServerGroups == nil {
		return nil, errors.New("invalid value for required argument 'ServerGroups'")
	}
	opts = pkgResourceDefaultOpts(opts)
	var resource ZPABrowserAccess
	err := ctx.RegisterResource("zpa:index/zPABrowserAccess:ZPABrowserAccess", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetZPABrowserAccess gets an existing ZPABrowserAccess resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetZPABrowserAccess(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ZPABrowserAccessState, opts ...pulumi.ResourceOption) (*ZPABrowserAccess, error) {
	var resource ZPABrowserAccess
	err := ctx.ReadResource("zpa:index/zPABrowserAccess:ZPABrowserAccess", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ZPABrowserAccess resources.
type zpabrowserAccessState struct {
	// Indicates whether users can bypass ZPA to access applications. Default: NEVER. Supported values: ALWAYS, NEVER, ON_NET.
	// The value NEVER indicates the use of the client forwarding policy.
	BypassType     *string                         `pulumi:"bypassType"`
	ClientlessApps []ZPABrowserAccessClientlessApp `pulumi:"clientlessApps"`
	ConfigSpace    *string                         `pulumi:"configSpace"`
	// Description of the application.
	Description *string `pulumi:"description"`
	// List of domains and IPs.
	DomainNames []string `pulumi:"domainNames"`
	// Whether Double Encryption is enabled or disabled for the app.
	DoubleEncrypt   *bool   `pulumi:"doubleEncrypt"`
	Enabled         *bool   `pulumi:"enabled"`
	HealthCheckType *string `pulumi:"healthCheckType"`
	// Whether health reporting for the app is Continuous or On Access. Supported values: NONE, ON_ACCESS, CONTINUOUS.
	HealthReporting *string `pulumi:"healthReporting"`
	IcmpAccessType  *string `pulumi:"icmpAccessType"`
	IpAnchored      *bool   `pulumi:"ipAnchored"`
	// Indicates if the Zscaler Client Connector (formerly Zscaler App or Z App) receives CNAME DNS records from the
	// connectors.
	IsCnameEnabled *bool `pulumi:"isCnameEnabled"`
	// Name of the application.
	Name                 *string `pulumi:"name"`
	PassiveHealthEnabled *bool   `pulumi:"passiveHealthEnabled"`
	SegmentGroupId       *string `pulumi:"segmentGroupId"`
	SegmentGroupName     *string `pulumi:"segmentGroupName"`
	// List of the server group IDs.
	ServerGroups []ZPABrowserAccessServerGroup `pulumi:"serverGroups"`
	// TCP port ranges used to access the app.
	TcpPortRanges []string `pulumi:"tcpPortRanges"`
	// UDP port ranges used to access the app.
	UdpPortRanges []string `pulumi:"udpPortRanges"`
}

type ZPABrowserAccessState struct {
	// Indicates whether users can bypass ZPA to access applications. Default: NEVER. Supported values: ALWAYS, NEVER, ON_NET.
	// The value NEVER indicates the use of the client forwarding policy.
	BypassType     pulumi.StringPtrInput
	ClientlessApps ZPABrowserAccessClientlessAppArrayInput
	ConfigSpace    pulumi.StringPtrInput
	// Description of the application.
	Description pulumi.StringPtrInput
	// List of domains and IPs.
	DomainNames pulumi.StringArrayInput
	// Whether Double Encryption is enabled or disabled for the app.
	DoubleEncrypt   pulumi.BoolPtrInput
	Enabled         pulumi.BoolPtrInput
	HealthCheckType pulumi.StringPtrInput
	// Whether health reporting for the app is Continuous or On Access. Supported values: NONE, ON_ACCESS, CONTINUOUS.
	HealthReporting pulumi.StringPtrInput
	IcmpAccessType  pulumi.StringPtrInput
	IpAnchored      pulumi.BoolPtrInput
	// Indicates if the Zscaler Client Connector (formerly Zscaler App or Z App) receives CNAME DNS records from the
	// connectors.
	IsCnameEnabled pulumi.BoolPtrInput
	// Name of the application.
	Name                 pulumi.StringPtrInput
	PassiveHealthEnabled pulumi.BoolPtrInput
	SegmentGroupId       pulumi.StringPtrInput
	SegmentGroupName     pulumi.StringPtrInput
	// List of the server group IDs.
	ServerGroups ZPABrowserAccessServerGroupArrayInput
	// TCP port ranges used to access the app.
	TcpPortRanges pulumi.StringArrayInput
	// UDP port ranges used to access the app.
	UdpPortRanges pulumi.StringArrayInput
}

func (ZPABrowserAccessState) ElementType() reflect.Type {
	return reflect.TypeOf((*zpabrowserAccessState)(nil)).Elem()
}

type zpabrowserAccessArgs struct {
	// Indicates whether users can bypass ZPA to access applications. Default: NEVER. Supported values: ALWAYS, NEVER, ON_NET.
	// The value NEVER indicates the use of the client forwarding policy.
	BypassType     *string                         `pulumi:"bypassType"`
	ClientlessApps []ZPABrowserAccessClientlessApp `pulumi:"clientlessApps"`
	ConfigSpace    *string                         `pulumi:"configSpace"`
	// Description of the application.
	Description *string `pulumi:"description"`
	// List of domains and IPs.
	DomainNames []string `pulumi:"domainNames"`
	// Whether Double Encryption is enabled or disabled for the app.
	DoubleEncrypt   *bool   `pulumi:"doubleEncrypt"`
	Enabled         *bool   `pulumi:"enabled"`
	HealthCheckType *string `pulumi:"healthCheckType"`
	// Whether health reporting for the app is Continuous or On Access. Supported values: NONE, ON_ACCESS, CONTINUOUS.
	HealthReporting *string `pulumi:"healthReporting"`
	IcmpAccessType  *string `pulumi:"icmpAccessType"`
	IpAnchored      *bool   `pulumi:"ipAnchored"`
	// Indicates if the Zscaler Client Connector (formerly Zscaler App or Z App) receives CNAME DNS records from the
	// connectors.
	IsCnameEnabled *bool `pulumi:"isCnameEnabled"`
	// Name of the application.
	Name                 *string `pulumi:"name"`
	PassiveHealthEnabled *bool   `pulumi:"passiveHealthEnabled"`
	SegmentGroupId       string  `pulumi:"segmentGroupId"`
	SegmentGroupName     *string `pulumi:"segmentGroupName"`
	// List of the server group IDs.
	ServerGroups []ZPABrowserAccessServerGroup `pulumi:"serverGroups"`
	// TCP port ranges used to access the app.
	TcpPortRanges []string `pulumi:"tcpPortRanges"`
	// UDP port ranges used to access the app.
	UdpPortRanges []string `pulumi:"udpPortRanges"`
}

// The set of arguments for constructing a ZPABrowserAccess resource.
type ZPABrowserAccessArgs struct {
	// Indicates whether users can bypass ZPA to access applications. Default: NEVER. Supported values: ALWAYS, NEVER, ON_NET.
	// The value NEVER indicates the use of the client forwarding policy.
	BypassType     pulumi.StringPtrInput
	ClientlessApps ZPABrowserAccessClientlessAppArrayInput
	ConfigSpace    pulumi.StringPtrInput
	// Description of the application.
	Description pulumi.StringPtrInput
	// List of domains and IPs.
	DomainNames pulumi.StringArrayInput
	// Whether Double Encryption is enabled or disabled for the app.
	DoubleEncrypt   pulumi.BoolPtrInput
	Enabled         pulumi.BoolPtrInput
	HealthCheckType pulumi.StringPtrInput
	// Whether health reporting for the app is Continuous or On Access. Supported values: NONE, ON_ACCESS, CONTINUOUS.
	HealthReporting pulumi.StringPtrInput
	IcmpAccessType  pulumi.StringPtrInput
	IpAnchored      pulumi.BoolPtrInput
	// Indicates if the Zscaler Client Connector (formerly Zscaler App or Z App) receives CNAME DNS records from the
	// connectors.
	IsCnameEnabled pulumi.BoolPtrInput
	// Name of the application.
	Name                 pulumi.StringPtrInput
	PassiveHealthEnabled pulumi.BoolPtrInput
	SegmentGroupId       pulumi.StringInput
	SegmentGroupName     pulumi.StringPtrInput
	// List of the server group IDs.
	ServerGroups ZPABrowserAccessServerGroupArrayInput
	// TCP port ranges used to access the app.
	TcpPortRanges pulumi.StringArrayInput
	// UDP port ranges used to access the app.
	UdpPortRanges pulumi.StringArrayInput
}

func (ZPABrowserAccessArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*zpabrowserAccessArgs)(nil)).Elem()
}

type ZPABrowserAccessInput interface {
	pulumi.Input

	ToZPABrowserAccessOutput() ZPABrowserAccessOutput
	ToZPABrowserAccessOutputWithContext(ctx context.Context) ZPABrowserAccessOutput
}

func (*ZPABrowserAccess) ElementType() reflect.Type {
	return reflect.TypeOf((**ZPABrowserAccess)(nil)).Elem()
}

func (i *ZPABrowserAccess) ToZPABrowserAccessOutput() ZPABrowserAccessOutput {
	return i.ToZPABrowserAccessOutputWithContext(context.Background())
}

func (i *ZPABrowserAccess) ToZPABrowserAccessOutputWithContext(ctx context.Context) ZPABrowserAccessOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ZPABrowserAccessOutput)
}

// ZPABrowserAccessArrayInput is an input type that accepts ZPABrowserAccessArray and ZPABrowserAccessArrayOutput values.
// You can construct a concrete instance of `ZPABrowserAccessArrayInput` via:
//
//	ZPABrowserAccessArray{ ZPABrowserAccessArgs{...} }
type ZPABrowserAccessArrayInput interface {
	pulumi.Input

	ToZPABrowserAccessArrayOutput() ZPABrowserAccessArrayOutput
	ToZPABrowserAccessArrayOutputWithContext(context.Context) ZPABrowserAccessArrayOutput
}

type ZPABrowserAccessArray []ZPABrowserAccessInput

func (ZPABrowserAccessArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ZPABrowserAccess)(nil)).Elem()
}

func (i ZPABrowserAccessArray) ToZPABrowserAccessArrayOutput() ZPABrowserAccessArrayOutput {
	return i.ToZPABrowserAccessArrayOutputWithContext(context.Background())
}

func (i ZPABrowserAccessArray) ToZPABrowserAccessArrayOutputWithContext(ctx context.Context) ZPABrowserAccessArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ZPABrowserAccessArrayOutput)
}

// ZPABrowserAccessMapInput is an input type that accepts ZPABrowserAccessMap and ZPABrowserAccessMapOutput values.
// You can construct a concrete instance of `ZPABrowserAccessMapInput` via:
//
//	ZPABrowserAccessMap{ "key": ZPABrowserAccessArgs{...} }
type ZPABrowserAccessMapInput interface {
	pulumi.Input

	ToZPABrowserAccessMapOutput() ZPABrowserAccessMapOutput
	ToZPABrowserAccessMapOutputWithContext(context.Context) ZPABrowserAccessMapOutput
}

type ZPABrowserAccessMap map[string]ZPABrowserAccessInput

func (ZPABrowserAccessMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ZPABrowserAccess)(nil)).Elem()
}

func (i ZPABrowserAccessMap) ToZPABrowserAccessMapOutput() ZPABrowserAccessMapOutput {
	return i.ToZPABrowserAccessMapOutputWithContext(context.Background())
}

func (i ZPABrowserAccessMap) ToZPABrowserAccessMapOutputWithContext(ctx context.Context) ZPABrowserAccessMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ZPABrowserAccessMapOutput)
}

type ZPABrowserAccessOutput struct{ *pulumi.OutputState }

func (ZPABrowserAccessOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ZPABrowserAccess)(nil)).Elem()
}

func (o ZPABrowserAccessOutput) ToZPABrowserAccessOutput() ZPABrowserAccessOutput {
	return o
}

func (o ZPABrowserAccessOutput) ToZPABrowserAccessOutputWithContext(ctx context.Context) ZPABrowserAccessOutput {
	return o
}

// Indicates whether users can bypass ZPA to access applications. Default: NEVER. Supported values: ALWAYS, NEVER, ON_NET.
// The value NEVER indicates the use of the client forwarding policy.
func (o ZPABrowserAccessOutput) BypassType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ZPABrowserAccess) pulumi.StringPtrOutput { return v.BypassType }).(pulumi.StringPtrOutput)
}

func (o ZPABrowserAccessOutput) ClientlessApps() ZPABrowserAccessClientlessAppArrayOutput {
	return o.ApplyT(func(v *ZPABrowserAccess) ZPABrowserAccessClientlessAppArrayOutput { return v.ClientlessApps }).(ZPABrowserAccessClientlessAppArrayOutput)
}

func (o ZPABrowserAccessOutput) ConfigSpace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ZPABrowserAccess) pulumi.StringPtrOutput { return v.ConfigSpace }).(pulumi.StringPtrOutput)
}

// Description of the application.
func (o ZPABrowserAccessOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ZPABrowserAccess) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// List of domains and IPs.
func (o ZPABrowserAccessOutput) DomainNames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ZPABrowserAccess) pulumi.StringArrayOutput { return v.DomainNames }).(pulumi.StringArrayOutput)
}

// Whether Double Encryption is enabled or disabled for the app.
func (o ZPABrowserAccessOutput) DoubleEncrypt() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ZPABrowserAccess) pulumi.BoolPtrOutput { return v.DoubleEncrypt }).(pulumi.BoolPtrOutput)
}

func (o ZPABrowserAccessOutput) Enabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *ZPABrowserAccess) pulumi.BoolOutput { return v.Enabled }).(pulumi.BoolOutput)
}

func (o ZPABrowserAccessOutput) HealthCheckType() pulumi.StringOutput {
	return o.ApplyT(func(v *ZPABrowserAccess) pulumi.StringOutput { return v.HealthCheckType }).(pulumi.StringOutput)
}

// Whether health reporting for the app is Continuous or On Access. Supported values: NONE, ON_ACCESS, CONTINUOUS.
func (o ZPABrowserAccessOutput) HealthReporting() pulumi.StringOutput {
	return o.ApplyT(func(v *ZPABrowserAccess) pulumi.StringOutput { return v.HealthReporting }).(pulumi.StringOutput)
}

func (o ZPABrowserAccessOutput) IcmpAccessType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ZPABrowserAccess) pulumi.StringPtrOutput { return v.IcmpAccessType }).(pulumi.StringPtrOutput)
}

func (o ZPABrowserAccessOutput) IpAnchored() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ZPABrowserAccess) pulumi.BoolPtrOutput { return v.IpAnchored }).(pulumi.BoolPtrOutput)
}

// Indicates if the Zscaler Client Connector (formerly Zscaler App or Z App) receives CNAME DNS records from the
// connectors.
func (o ZPABrowserAccessOutput) IsCnameEnabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ZPABrowserAccess) pulumi.BoolPtrOutput { return v.IsCnameEnabled }).(pulumi.BoolPtrOutput)
}

// Name of the application.
func (o ZPABrowserAccessOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *ZPABrowserAccess) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

func (o ZPABrowserAccessOutput) PassiveHealthEnabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *ZPABrowserAccess) pulumi.BoolOutput { return v.PassiveHealthEnabled }).(pulumi.BoolOutput)
}

func (o ZPABrowserAccessOutput) SegmentGroupId() pulumi.StringOutput {
	return o.ApplyT(func(v *ZPABrowserAccess) pulumi.StringOutput { return v.SegmentGroupId }).(pulumi.StringOutput)
}

func (o ZPABrowserAccessOutput) SegmentGroupName() pulumi.StringOutput {
	return o.ApplyT(func(v *ZPABrowserAccess) pulumi.StringOutput { return v.SegmentGroupName }).(pulumi.StringOutput)
}

// List of the server group IDs.
func (o ZPABrowserAccessOutput) ServerGroups() ZPABrowserAccessServerGroupArrayOutput {
	return o.ApplyT(func(v *ZPABrowserAccess) ZPABrowserAccessServerGroupArrayOutput { return v.ServerGroups }).(ZPABrowserAccessServerGroupArrayOutput)
}

// TCP port ranges used to access the app.
func (o ZPABrowserAccessOutput) TcpPortRanges() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ZPABrowserAccess) pulumi.StringArrayOutput { return v.TcpPortRanges }).(pulumi.StringArrayOutput)
}

// UDP port ranges used to access the app.
func (o ZPABrowserAccessOutput) UdpPortRanges() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ZPABrowserAccess) pulumi.StringArrayOutput { return v.UdpPortRanges }).(pulumi.StringArrayOutput)
}

type ZPABrowserAccessArrayOutput struct{ *pulumi.OutputState }

func (ZPABrowserAccessArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ZPABrowserAccess)(nil)).Elem()
}

func (o ZPABrowserAccessArrayOutput) ToZPABrowserAccessArrayOutput() ZPABrowserAccessArrayOutput {
	return o
}

func (o ZPABrowserAccessArrayOutput) ToZPABrowserAccessArrayOutputWithContext(ctx context.Context) ZPABrowserAccessArrayOutput {
	return o
}

func (o ZPABrowserAccessArrayOutput) Index(i pulumi.IntInput) ZPABrowserAccessOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ZPABrowserAccess {
		return vs[0].([]*ZPABrowserAccess)[vs[1].(int)]
	}).(ZPABrowserAccessOutput)
}

type ZPABrowserAccessMapOutput struct{ *pulumi.OutputState }

func (ZPABrowserAccessMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ZPABrowserAccess)(nil)).Elem()
}

func (o ZPABrowserAccessMapOutput) ToZPABrowserAccessMapOutput() ZPABrowserAccessMapOutput {
	return o
}

func (o ZPABrowserAccessMapOutput) ToZPABrowserAccessMapOutputWithContext(ctx context.Context) ZPABrowserAccessMapOutput {
	return o
}

func (o ZPABrowserAccessMapOutput) MapIndex(k pulumi.StringInput) ZPABrowserAccessOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ZPABrowserAccess {
		return vs[0].(map[string]*ZPABrowserAccess)[vs[1].(string)]
	}).(ZPABrowserAccessOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ZPABrowserAccessInput)(nil)).Elem(), &ZPABrowserAccess{})
	pulumi.RegisterInputType(reflect.TypeOf((*ZPABrowserAccessArrayInput)(nil)).Elem(), ZPABrowserAccessArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ZPABrowserAccessMapInput)(nil)).Elem(), ZPABrowserAccessMap{})
	pulumi.RegisterOutputType(ZPABrowserAccessOutput{})
	pulumi.RegisterOutputType(ZPABrowserAccessArrayOutput{})
	pulumi.RegisterOutputType(ZPABrowserAccessMapOutput{})
}
